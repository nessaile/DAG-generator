
import Pkg
using Combinatorics, DataFrames, LinearAlgebra, StatsBase, Base.Threads, Octavian

function DAG_space_gen(n)
    nthreads = Threads.nthreads()

    m = binomial(n, 2)
    choices = repeat(collect.([0:1]), m)
    choices = Base.product(choices...) |> DataFrame
    nchoices = 2^m
    pvertex = permutations(1:n) |> collect
    npvertex = factorial(n)
    idmatrix = [[convert.(Int8, Matrix(1I, n, n))] for _ in 1:nthreads]
    adjc_matrix = [[convert.(Int8, Matrix(0I, n, n))] for _ in 1:nthreads]

    multiple = convert(Int, nchoices / nthreads)
    bins = Matrix[]
    for q in 1:multiple
        if size(bins, 1) < 1
            push!(bins, [2 (multiple * q)])
        else
            push!(bins, [(bins[q-1][2]+1) (multiple * q)])
        end
    end

    @threads for a in 1:nthreads
        #println(Threads.threadid())
        threadID = Threads.threadid()

        for i in bins[threadID][1]:bins[threadID][2]
            base_matrix = convert.(Int8, fill(99, (n, n)))
            upper_triangle = LowerTriangular(base_matrix) .== 0
            base_matrix[upper_triangle] = collect(choices[i, :])
            replace!(base_matrix, 99 => 0)

            for j in 1:npvertex
                #candidate = idmatrix[threadID][][:, pvertex[j]] * base_matrix * idmatrix[threadID][][pvertex[j], :]
                candidate = matmul!(idmatrix[threadID][][:, pvertex[j]], base_matrix, idmatrix[threadID][][pvertex[j], :])
                push!(adjc_matrix[threadID], candidate)
            end
        end
    end

    return unique(reduce(vcat, adjc_matrix))
end

for i in 2:

@time x = DAG_space_gen(5)

